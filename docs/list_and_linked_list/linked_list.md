# [4.2 链表](https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list/)

为什么需要链表？因为在实际情况中，我们不能保证空闲内存空间都是连续的，但是存储数组的内存空间必须是连续的，当数组非常大时，内存可能无法提供如此大的连续空间，此时，链表的灵活性优势就体现出来了。

## 链表

「链表 linked list」是一种线性数据结构，每个元素都是一个**Node**对象，各个节点通过**引用** 相连接。引用记录了下个Node的内存地址，可以从当前Node访问到下一个Node。**（其实就是使用指针来指向下个Node的地址）**

链表的设计使得各个Node 可以分散在内存各处，无需**内存地址连续**。

![](https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png)

Linked List 的组成单位是 **「节点 node」** 对象。每个 Node 包括：Node的值和指向下个Node的指针。

- 链表的首个Node 称为"Head Node"，最后一个 Node 称为 ""

List Node的数据结构为：

```go
type ListNode struct{
    Val int             // Node Value
    Next *ListNode      // 指向下个Node的指针
}

// NewListNode
func NewListNode(val int) *ListNode{
    return &ListNode{
    Val: val,
    Next: nil,
    }
}
```

## 链表常用操作

### 1. 初始化链表

先初始化各个Node对象，第二部构建指针指向。初始化完成后，从链表的Head Node出发，通过指针指向 `next` ，一次访问所有节点。

```go
/* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */
// 初始化各节点
n0 := NewListNode(1)
n1 := NewListNode(3)
n2 := NewListNode(2)
n3 := NewListNode(5)
n4 := NewListNode(4)
// 构建引用指向 （指针）
n0.Next = n1
n1.Next = n2
n2.Next = n3
n3.Next = n4
```

数组的整体是一个变量，包含元素num[index].

而链表是由多个独立的节点对象组成的。**通常吧头节点当作链表的代称**，例如上面的链表可记作链表`n0`

### 2. 插入节点

在链表插入节点非常容易。例如现在`n0`和`n1`间插入新节点`P`，**只需要改变两个相邻的节点的指针即可**，时间复杂度为O(1).

![](https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_insert_node.png)

```go
/* 在链表的节点 n0 之后插入节点 P*/
func insertNode(n0 *ListNode, P *ListNode){
    n1:=n0.Next // 仅为方便理解 非必须
    P.Next=n1
    n0.Next=p
}
```

### 3. 删除节点

删除节点，同样只需改变一个节点的指针即可。

注意，尽管删除后节点`P`仍然指向`n1`，但实际上遍历此链表已经无法访问到`P`，这意味着`P`已经不再属于该链表了。

![](https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_remove_node.png)

```go
/* 删除链表的节点 n0 之后的首个节点 */
func removeNode(n0 *ListNode){
    if n0.Next==nil{
    return
    }
    // n0 -> P -> n1
    P:=n0.Next // 仅为方便理解，非必须
    n1:=P.Next
    n0.Next=n1
}
```

### 4. 访问节点

**在链表访问节点的效率较低**。需要从头节点向后遍历直到找到目标节点。

> 如上节所述，我们可以在O(1)时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第 i 个节点需要循环 i-1 轮，时间复杂度为 O(n) 。

```go
/* 访问链表中索引为 index 的节点 */
func access(head *ListNode index int) *ListNode{
    for i := 0; i < index; i++ {
        if head == nil {
            return nil
        }
        head = head.Next
    }
    return head
}
```

### 5.查找节点

遍历链表，查找链表内值为`target`的节点，输出节点在链表中的索引。此过程也属于线性查找。

```go
/* 在链表中查找值为 target 的首个节点 */
func findNode(head *ListNode, target int) int{
    index:=0
    for head != nil{
        if head.Val == target {
            return index
        }
        head = head.Next
        index++
    }
    return -1
}
```

## 数组 VS 链表

|       | 数组           | 链表     |
| ----- | ------------ | ------ |
| 存储方式  | 连续内存空间       | 分散内存空间 |
| 缓存局部性 | 友好           | 不友好    |
| 容量扩展  | 长度不可变        | 可灵活扩展  |
| 内存效率  | 占用内存少、浪费部分空间 | 占用内存多  |
| 访问元素  | O(1)         | O(n)   |
| 添加元素  | O(n)         | O(1)   |
| 删除元素  | O(n)         | O(1)   |

常见链表类型

- 单向链表：即普通链表。Node包含值和指向下个Node的指针两项数据。我们将首个节点称为头节点，最后一个阶段称为尾节点，尾节点指针指向 nil

- 环形链表：令单向链表的尾节点指向头节点（首尾相接），则得到环形链表。在环形链表中，任意节点都可视作头节点。

- 双向链表：与单向链表相比，双向链表记录了两个方向的指针。双向链表的node定义同时包含指向后继结点（下个节点）和前驱节点（上个节点）的指针（引用）。相较于单向链表更灵具活性，可以朝两个方向遍历链表，但也需要占用更多内存空间。

```go
/* 双向链表结构体 */
type DoublyListNode struct{
    Val int     // 节点值
    Next *DoublyListNode // 指向后继结点的指针
    Prev *DoublyListNode // 指向前驱结点的指针
}

//  NewDoublyListNode 初始化
func NewDoublyListNode(val int) *DoublyListNode{
    return &DoublyListNode{
        Val: val,
        Next: nil,
        Prev: nil,
    }
}
```

![](https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_common_types.png)

## 链表典型应用

单向链表通常用于实现栈、队列、哈希表和图等数据结构。

- **栈与队列**：当插入和删除操作都在链表的一端进行时，他体现出先进后出FILO，对应 **栈**；当插入操作在链表的一端进行，删除操作在另一端进行，体现出先进先出FIFO，对应**队列**

- **哈希表**：链地址法是解决哈希冲突的主流方案之一，所有冲突的元素都会被放到一个链表中。

- **图**：邻接表是表示图的一种常用方式，在其中，图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。

双向链表常被用于需要快速查找前一个和下一个元素的场景。

- **高级数据结构**：比如在红黑树、B树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向指向父节点的引用来实现，类似于双向链表。

- **浏览器历史**：在网页浏览器中，当用户点击前进后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。

- **LRU算法**：在缓存淘汰算法(LRU)中，我们需要快速找到最近最少使用的数据，以及支持快速地添加和删除节点。

循环链表常被用于需要周期性操作的场景，比如操作系统的资源调度。

- **时间片轮转调度算法**：在操作系统中，时间片轮转调度算法是一种常见的CPU调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完后，CPU将切换到下一个进程。这种循环的操作就可以通过循环链表来实现。

- **数据缓冲区**：在某些数据缓冲区的实现中，也可能会使用到循环链表。比如在音频、视频播放器中，数据流可能被分成多个缓冲块并放入一个循环链表，以便实现无缝播放。

### 常见引用补充

> 可以添加一些链表的常见应用
> 
> ### 单向链表
> 
> 单向链表是一种常见的链表结构，每个节点包含一个指向下一个节点的指针。
> 
> 1. 资源管理：单向链表可以用来管理资源，例如内存分配中的空闲块链表，通过将空闲的内存块连接成一个链表，可以方便地进行分配和释放。
> 2. 队列实现：单向链表可以用于实现队列（FIFO）的数据结构，通过在链表的尾部添加元素，并在链表的头部移除元素，可以实现高效的入队和出队操作。
> 3. 图的表示：在图的表示中，每个顶点通常包含一个指向其邻居顶点的链表。单向链表可以用于表示有向图或无向图中顶点的邻居关系。
> 4. 任务调度：在任务调度系统中，可以使用单向链表来管理待执行的任务列表，通过将任务连接成一个链表，可以按照特定的顺序进行调度和执行。
> 5. 多级反馈队列调度算法：多级反馈队列调度算法中，任务被分成多个优先级队列，并按照一定规则进行调度。每个队列可以使用单向链表来管理任务，实现按优先级进行任务调度。
> 6. 符号表和字典实现：在符号表和字典的实现中，可以使用单向链表来存储键值对。每个节点包含一个键和一个值，并通过指针连接成一个链表，实现高效的查找、插入和删除操作。
> 
> ### 环形链表
> 
> 首尾相接的链表结构，
> 
> 1. 约瑟夫问题（Josephus Problem）：在约瑟夫问题中，有n个人围成一个环形，每次从指定位置开始计数，并按照固定规则将当前位置的人移出环形，直到最后只剩下一个人。环形链表可以用来模拟和解决这个问题。
> 2. 循环队列（Circular Queue）：循环队列是一种特殊的队列数据结构，当队列的尾部达到数组的末尾时，可以绕回数组的开头，形成一个循环。环形链表可以用来实现循环队列，提供高效的队列操作。
> 3. 循环链表遍历：使用环形链表可以实现循环遍历，即从任意节点开始遍历整个链表，而不会出现遍历到尾节点后的终止条件。
> 4. 环形缓冲区（Circular Buffer）：环形缓冲区是一种常见的数据结构，用于在固定大小的缓冲区中循环存储数据。环形链表可以用来实现环形缓冲区，实现高效的数据读写操作。
> 5. 快慢指针算法（Floyd's Cycle Detection Algorithm）：快慢指针算法是一种使用两个指针在环形链表中寻找环的算法。该算法可以应用于检测环形链表中是否存在环以及找到环的起始节点等问题。
> 
> ### 双向链表
> 
> 双向链表是一种链表结构，每个节点都包含指向前一个节点和后一个节点的指针。
> 
> 1. LRU缓存（Least Recently Used Cache）：LRU缓存是一种常见的缓存替换策略，其中最近最少使用的数据被淘汰。双向链表可以用来实现LRU缓存，每次访问数据时，将其移到链表的头部，这样尾部的节点就是最近最少使用的数据，可以方便地淘汰。
> 2. 双向队列（Deque）：双向队列是一种具有队列和栈的特性的数据结构，可以在队列的头部和尾部进行插入和删除操作。双向链表可以用来实现双向队列，提供高效的插入和删除操作。
> 3. 图的表示：在图的表示中，每个顶点通常包含一个指向其邻居顶点的链表。双向链表可以用于表示有向图或无向图中顶点的邻居关系，每个顶点可以同时保存指向前一个邻居和后一个邻居的指针。
> 4. 浏览器历史记录：在浏览器中，双向链表可以用来实现浏览器的历史记录功能。每次访问一个新的页面，将其添加到链表的尾部，可以方便地实现前进和后退功能。
> 5. 文本编辑器的撤销和重做操作：在文本编辑器中，双向链表可以用来实现撤销和重做操作。每次编辑操作都可以将编辑内容添加到链表的尾部，可以通过向前或向后遍历链表来实现撤销和重做操作。
> 6. 音乐播放器的播放列表：在音乐播放器中，双向链表可以用来实现播放列表，每个节点表示一个音乐文件，可以方便地在当前歌曲的前后插入或删除歌曲。
